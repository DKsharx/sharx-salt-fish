from urllib.parse import urlparseimport requestsimport timefrom script.utils.logger.logger import loggerclass FastestMirror:    @staticmethod    def get_github_mirror(download_url):        # mirror_urls = [        #     download_url,        #     f"https://github.kotori.top/{download_url}",        # ]        # return FastestMirror.find_fastest_mirror(mirror_urls, 10)        return f"https://github.kotori.top/{download_url}"    @staticmethod    def get_github_api_mirror(user, repo, latest=True):        # mirror_urls = [        #     f"https://api.github.com/repos/{user}/{repo}/releases/latest",        #     f"https://github.kotori.top/https://api.github.com/repos/{user}/{repo}/releases/latest",        # ]        # return FastestMirror.find_fastest_mirror(mirror_urls, 5)        if latest:            return f"https://github.kotori.top/https://api.github.com/repos/{user}/{repo}/releases/latest"        else:            return f"https://github.kotori.top/https://api.github.com/repos/{user}/{repo}/releases"    @staticmethod    def get_pypi_mirror(timeout=5):        return FastestMirror.find_fastest_mirror(['https://mirrors.cloud.tencent.com/pypi/simple/',                                                  'https://mirrors.aliyun.com/pypi/simple/',                                                  'https://pypi.org/simple/'], timeout)    @staticmethod    def find_fastest_mirror(mirror_urls, timeout=5):        # from managers.logger_manager import logger        import concurrent.futures        def check_mirror(mirror_url):            try:                start_time = time.time()                response = requests.head(mirror_url, timeout=timeout, allow_redirects=True)                end_time = time.time()                if response.status_code == 200:                    response_time = end_time - start_time                    logger.debug("镜像: {mirror} 响应时间: {time}".format(mirror=urlparse(mirror_url).netloc,                                                                          time=response_time))                    return mirror_url            except Exception:                pass            return None        # logger.info(_("开始测速"))        with concurrent.futures.ThreadPoolExecutor() as executor:            future_to_mirror = {executor.submit(check_mirror, mirror_url): mirror_url for mirror_url in mirror_urls}            for future in concurrent.futures.as_completed(future_to_mirror):                result = future.result()                if result:                    executor.shutdown()                    logger.info("最快的镜像为: {mirror}".format(mirror=urlparse(result).netloc))                    return result        logger.warning("测速失败，使用默认镜像：{mirror}".format(mirror=urlparse(mirror_urls[0]).netloc))        return mirror_urls[0]